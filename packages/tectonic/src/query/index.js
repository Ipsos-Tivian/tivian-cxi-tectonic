'use strict';

import * as status from '/src/status';
import {
  GET,
  CREATE,
  UPDATE,
  DELETE,
  RETURNS_ITEM,
  RETURNS_LIST,
  RETURNS_ALL_FIELDS
} from '/src/consts';
import deepEqual from 'deep-equal';

/**
 * Query represents an API query to be resolved by the resolver. It is generated
 * directly from a model and contains thing such as fields required, parameters,
 * and whether we're loading a single item or a list.
 *
 * Queries are added to the resolver via the @load component and manager. It is
 * the resolver's responsibility to identify which sources satisfy the query.
 */
export default class Query {

  /**
   * When resolved we set the query's sourceDefinition property for tracking.
   */
  sourceDefinition = undefined

  /**
   * Represents the query status for an individual query.
   *
   * This is **extremely important** due to nuances: if this is SUCCESS, the
   * manager will **always** load data for this query from the store regardless
   * of cache validation.
   *
   * Background:
   *
   * - If a query response has a max-age of 0 we should discard the data on
   *   another page load OR component mount, but ignore caching when loading
   *   props for rendering or dependent data.
   *
   * - We only set the query status directly after resolving a query. This means
   *   that we can guarantee that a query instance with status of SUCCESS is
   *   fresh and can ignore the cache
   */
  status = undefined

  /**
   * Duplicates stores references to other query instances which are duplicates
   * of this query. When we update the status property we also update the status
   * of each duplicate.
   * 
   * See baseResolver.addQuery for more information.
   */
  duplicates = []

  /**
   * @param Model  model class
   * @param array|string   Array of fields or RETURNS_ALL_FIELDS
   * @param string GET, CREATE, UPDATE, or DELETE from consts above. Specifies
   *               the type of query to be sent across and match for in the
   *               sources list. Defaults to GET
   * @param string RETURNS_ITEM, RETURNS_LIST, or RETURNS NONE. Specifies
   *               whether the GET query is for a single model or list of models
   * @param object Object of query parameters to values
   * @param object Body to be sent in request, used for POST, PUT etc.
   * @param mixed  ID of the model instance for UPDATE and DELETE queries
   */
  constructor({ model, fields, queryType = GET, returnType, params = {}, body, callback, modelId }) {
    if (model.constructor && model.constructor.assertFieldsExist) {
      model.constructor.assertFieldsExist(fields);
    } else {
      model.assertFieldsExist(fields);
    }

    this.model = model;
    this.modelId = modelId;
    this.fields = Array.isArray(fields) ? fields.sort() : fields;
    this.params = params;
    this.returnType = returnType;
    this.queryType = queryType;
    this.body = body;
    this.callback = callback;

    this.children = [];

    // To create query trees we need to iterate through each param and see if
    // the value is a function; if it is we assume this was created via
    // PropInspector and calculates this Query's parent query.
    Object.keys(params).forEach(p => {
      const param = params[p];
      if (typeof param === 'function') {
        // Call the accessor generated by PropInspector using this query as the
        // context. This will create the parent-child tree relationships.
        this.params[p] = param.call(this);
      }
    });

    // When the query is resolved and data is found this stores all of the IDs
    // returned by the API for the given model. This is then stored in a map of
    // query => IDs so that when we load props for a component we look up this
    // hash then look up our data.
    //
    // This means that we can query on arbitrary things such as ranges and
    // emails without knowing the IDs to look up, as the API tells us (plus we
    // store all data by ID).
    //
    // By default this is an empty array so we can push to it.
    //
    // Also, by making this an ES6 set we guarantee uniqueness so as to not
    // check the 
    this.returnedIds = new Set();
  }

  toString() {
    return `Query(Model: ${this.model.modelName}, ` +
      `Fields: ${this.fields}, ` +
      `Params: ${JSON.stringify(this.params)}, ` +
      `Body: ${JSON.stringify(this.body)}, ` +
      `QueryType: ${this.queryType}), ` +
      `ReturnType: ${this.returnType})`;
  }

  /**
   * Returns whether the current query instance is the same
   */
  is(item) {
    const comparisons = [
      'model',
      'fields',
      'params',
      'returnType',
      'queryType',
      'body'
    ];

    return comparisons.every(field => {
      return deepEqual(this[field], item[field]) === true;
    });
  }

  /**
   * hash returns a hashed value of toString() that can be used to uniquely
   * identify this query.
   *
   * This is memoized for speed.
   */
  hash() {
    return this.toString();
  }

  updateStatus(to) {
    this.status = to;
    this.duplicates.forEach(dupe => dupe.status = to);
  }

}
