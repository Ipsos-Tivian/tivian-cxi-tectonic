import {
  UPDATE_DATA,
  DELETE_DATA,
} from '../reducer';
import {
  RETURNS_ITEM,
  RETURNS_LIST,
  GET,
  DELETE,
} from '../consts';

/**
 * Cache represents an abstraction over redux' store for saving and reading
 * data.
 *
 * TODO: Per-model cache rules
 * TODO: custom cache rules and predicates
 */
export default class Cache {

  /**
   * store holds a reference to the redux store
   */
  store = undefined;

  constructor(store) {
    if (store === undefined || store.dispatch === undefined || store.getState === undefined) {
      throw new Error('Cache must be defined with a redux store');
    }
    this.store = store;
  }

  /**
   * storeQuery is called from the resolver after a successful query to store
   * data in the reducer for future components.
   *
   * @param Query
   * @param SourceDefinition
   * @param {(object|array)} - array containing list of data, object of
   * poylmorphic data or an object of a single API response. If the API returned
   * 204 this should be undefined.
   * @param Date - date at which this data should expire
   */
  storeQuery(query, sourceDef, apiResponse, expires = new Date()) {
    if (query.queryType === DELETE) {
      // Add the ID of this model to the delete blacklist
      if (query.modelId === undefined) {
        throw new Error('unknown model ID during DELETE in query: ', query);
      }

      this.store.dispatch({
        type: DELETE_DATA,
        payload: {
          query,
          model: query.model,
          modelName: query.model.modelName,
          modelId: `${query.modelId}`, // modelIds should always be strings in reducers
        },
      });
      return;
    }

    if (!apiResponse) {
      // Probably a 204 - we can back out safely.
      return;
    }

    const data = this.parseApiData(query, sourceDef, apiResponse, expires);

    // Store the parsed data and the IDs generated by said query within our
    // state
    this.store.dispatch({
      type: UPDATE_DATA,
      payload: {
        data,
        query,
        expires,
      },
    });
  }

  /**
   * parseApiData takes an entire API response and formats each model's data in
   * the storage format to store within redux.
   *
   * The return is formatted like so:
   * {
   *   [model.modelName]: {
   *     [id]: {
   *       data: {...},
   *       cache: {...},
   *     },
   *     ...
   *   },
   *   ...
   * }
   *
   * @param Query
   * @param SourceDefinition
   * @param object
   * @param Date  timestamp to add within cache, defaults to now. Used in
   * testing
   * @return object
   */
  parseApiData(query, sourceDef, apiResponse, expires = new Date()) {
    const toStore = {};

    if (sourceDef.isPolymorphic()) {
      // The source definition returns more than one model, where each key
      // defines a particular model that it returns.
      //
      // Process all of them and add them to `toStore` so we update the store
      // once.
      Object.keys(sourceDef.returns).forEach((key) => {
        const returns = sourceDef.returns[key];
        // Get the return data for this particular key in the
        const returnData = this
          .parseReturnsData(query, returns, returns.model, apiResponse[key], expires);
        toStore[returns.model.modelName] = returnData;
      });
    } else {
      // this returns just one model (whether that's an individual model or
      // a list of the same models)
      const returnData = this
        .parseReturnsData(query, sourceDef.returns, sourceDef.returns.model, apiResponse, expires);
      toStore[sourceDef.returns.model.modelName] = returnData;
    }

    return toStore;
  }

  /**
   * parseReturnsData produces an object we save in the redux store for each
   * Returns instance within a sourceDefinition.
   *
   * For a single Returns instance this will produce an object as follows:
   * {
   *   [id]: {
   *     data: {...},
   *     cache: {...},
   *   }
   * }
   *
   * If the model of the data we're passing matches the queried for model, this
   * also adds the model IDs to the query (each query can specify a SINGLE
   * model). This allows us to cache the model IDs returned for a given query,
   * which aids in lookups.
   *
   * For example, if the query was for a list of Posts and the endpoint returned
   * the User AND the posts, this would add all returned post IDs to the query
   * only.
   *
   * @param Query   Query so we can add the IDs of returned data to the query
   * for caching
   * @param Returns
   * @param Model
   * @param object API data
   * @param Date  timestamp to add within cache, defaults to now. Used in
   * testing
   * @return object
   */
  parseReturnsData(query, returns, model, apiResponse, expires) {
    let resp = apiResponse;
    if (returns.returnType === RETURNS_LIST && !Array.isArray(apiResponse)) {
      throw new Error('Data for returning a list must be an array', apiResponse);
    }

    if (returns.returnType === RETURNS_ITEM && apiResponse.constructor.toString().indexOf('Object') === -1) {
      throw new Error('Data for returning an item must be an object', apiResponse);
    }

    if (returns.returnType === RETURNS_ITEM) {
      // standardize to list so we deal with one case. laziness meeans love
      // homie
      resp = [apiResponse];
    }


    // Take each instance of model data from the API response and save it in an
    // object to store in redux.
    //
    // We store things in a tree of modelName => id => { data: ..., cache: ...
    // }.
    //
    // modelData will contain a map of IDs to data and cache objects
    return resp.reduce((toStore, item) => {
      if (typeof item !== 'object') {
        throw new Error('Unable to process data from API; data is not an object', item);
      }

      const { idField } = model;
      const id = item[idField];

      if (id === undefined) {
        throw new Error('Unable to process data from API; data is missing the ID attribute', item);
      }

      // Each query needs to store the IDs of the model it queried for.
      // This is handled in the reducer when UPDATE_DATA is called via
      // storeQuery.
      if (query.model === model) {
        // Make sure the ID is a string
        query.returnedIds.add(`${id}`);
      }

      toStore[id] = {
        data: item,
        // Each particular model stores its expiry expires which is taken from
        // response headers.  In the future this will let us determine whether
        // a query can be skipped based on the IDs it expects and each model's
        // cache information
        cache: {
          expires,
        },
      };

      return toStore;
    }, {});
  }

  /**
   * Returns the IDs returned by this query if it's cached in
   * state/queriesToIds. If the data is in queriesToIds we've *definitely*
   * called this query before; we only need to determine whether the cached data
   * is stale.
   *
   */
  cachedQueryIds(query, state) {
    return state.getIn(['queriesToIds', query.hash()], new Set());
  }

  /**
   * getQueryData inspects the given state for the current model for the
   * necessary data and returns it if so.
   *
   * @param Query  Query, which must have a filled .returnedIds
   * @param Map    Tectonic's reducer state (store.getState().tectonic)
   * @return tuple:[data,bool] Data and bool indicating whether item was in
   * cache
   */
  getQueryData(query, state) {
    // Non-GET queries such as post, put, delete, patch should never have cached
    // data. This ensures that any resolver retries the data, as a resolver
    // should ONLY skip the request if this returns a tuple with false
    // indicating it's not in the cache.
    if (query.queryType !== GET) {
      return [undefined, false];
    }

    const returnedIds = this.cachedQueryIds(query, state);

    // No IDs were returned when we queried for this item
    if (returnedIds.size === 0) {
      const returns = (query.returnType === RETURNS_LIST) ? [] : undefined;
      return [returns, true];
    }

    if (query.returnType === RETURNS_ITEM && returnedIds.size !== 1) {
      throw new Error(`Invalid returnedIds length for a single item call: ${returnedIds}`);
    }

    const { modelName } = query.model;

    if (query.returnType === RETURNS_ITEM) {
      // XXX tidy this pluck
      const map = state.getIn(['data', modelName, returnedIds.values().next().value]);
      const data = this.processCachedModelMap(map);
      if (data === false) {
        return [undefined, false];
      }
      return [data, true];
    }

    // This returns many items in a list; iterate through all of the returned
    // IDs and fetch our data
    const data = Array.from(returnedIds).map(
      id => this.processCachedModelMap(state.getIn(['data', modelName, id]))
    );

    if (data.some(item => item === false)) {
      return [data.filter(Boolean), false];
    }

    return [data, true];
  }

  /**
   * processCachedModelMap validates a model instance's data plucked from the
   * cache.
   *
   * It returns false if the data has expired, doesn't exist or has been
   * deleted, otherwise it returns the model instance data itself
   *
   * @param Map
   * @return Object
   */
  processCachedModelMap(map) {
    if (map === undefined) {
      return false;
    }

    const { data, cache, deleted } = map.toObject();

    if (cache !== undefined && cache.expires !== undefined) {
      const { expires } = cache;
      // Check the expires header to see if the model is out of date.
      // Fudge the expiry date by +1 second to avoid timing issues.
      // XXX should we store expiry per-model or per query? This might not be
      // necessary
      if (expires.setSeconds(expires.getSeconds() + 1) < new Date()) {
        return false;
      }
    }

    if (deleted === true) {
      return false;
    }
    return data.toJS();
  }

  getQueryStatus(query, state) {
    return state.getIn(['status', query.hash()]);
  }

  /**
   * Returns whether a query has expired, given tectonic state.
   * If there is no expiry time for a query this will always return true.
   *
   * @return bool
   */
  hasQueryExpired(query, state) {
    return state.getIn(['queriesToExpiry', query.hash()], 0) < new Date();
  }

}
